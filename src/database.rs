use crate::{
    error::{self, internal_server_error},
    user::UserKind,
};
use chrono::Utc;
use chrono::{DateTime, SecondsFormat};
use error::not_found;
use mongodb::bson::{doc, Document};
use std::result::Result;
use tokio::stream::StreamExt;
use warp::Rejection;

use async_trait::async_trait;

const OBJECT_ID: &'static str = "objectId";
const CREATED_AT: &'static str = "createdAt";
const UPDATED_AT: &'static str = "updatedAt";

#[async_trait]
pub trait Database {
    async fn from_url(url: String) -> Self;

    async fn create(
        &self,
        class: &str,
        mut doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection>;

    async fn retrieve(
        &self,
        class: &str,
        filter: Document,
        user: UserKind,
    ) -> Result<Vec<Document>, Rejection>;

    async fn update(
        &self,
        class: &str,
        id: &str,
        mut doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection>;

    async fn delete(&self, class: &str, id: &str, user: UserKind) -> Result<Document, Rejection>;
}

#[derive(Debug, Clone)]
pub struct Mongodb {
    url: String,
    client: mongodb::Client,
    db: mongodb::Database,
}

impl Mongodb {
    // ID is generated by MongoDB, including objectID and createdAt
    const ID: &'static str = "_id";
    const UPDATED_AT: &'static str = "_updated_at";
    const ACL: &'static str = "_acl";
    const GUEST_ID: &'static str = "_guest";

    fn update_doc(doc: &mut Document, t: DateTime<Utc>) {
        doc.insert(Self::UPDATED_AT, t);
    }

    fn income(mut doc: Document) -> Document {
        if let Ok(id) = doc.get_object_id(OBJECT_ID) {
            let id = id.clone();
            doc.insert(Self::ID, id.to_string());
            doc.remove(OBJECT_ID);
        }
        doc
    }

    fn expose(mut doc: Document) -> Document {
        if let Ok(id) = doc.get_object_id(Self::ID) {
            let id = id.clone();
            doc.insert(
                CREATED_AT,
                id.timestamp().to_rfc3339_opts(SecondsFormat::Secs, true),
            );
            doc.insert(OBJECT_ID, id.to_string());
            doc.remove(Self::ID);
        }
        if let Ok(x) = doc.get_datetime(Self::UPDATED_AT) {
            doc.insert(UPDATED_AT, x.to_rfc3339_opts(SecondsFormat::Secs, true));
            doc.remove(Self::UPDATED_AT);
        }
        doc
    }

    fn read_filter(user: &UserKind) -> Document {
        match user {
            UserKind::Master => {
                doc! {}
            }
            UserKind::Client(user) => {
                doc! {"$or": vec![
                    doc! {format!("{}.{}.r", Self::ACL, user.id): true},
                    doc! {format!("{}.*.r", Self::ACL): true},
                ]}
            }
            UserKind::Guest => {
                let acl_all = format!("{}.*.w", Self::ACL);
                doc! { acl_all: true }
            }
        }
    }

    fn write_filter(user: &UserKind) -> Document {
        match user {
            UserKind::Master => {
                doc! {}
            }
            UserKind::Client(user) => {
                doc! {"$or": vec![
                    doc! {format!("{}.{}.w", Self::ACL, user.id): true},
                    doc! {format!("{}.*.w", Self::ACL): true},
                ]}
            }
            UserKind::Guest => {
                let acl_all = format!("{}.*.w", Self::ACL);
                doc! { acl_all: true }
            }
        }
    }
}

#[async_trait]
impl Database for Mongodb {
    async fn from_url(url: String) -> Self {
        let client_options = mongodb::options::ClientOptions::parse(&url).await.unwrap();
        let name = client_options
            .clone()
            .credential
            .unwrap()
            .source
            .expect("mongodb database name should be provided in url.");
        let client = mongodb::Client::with_options(client_options).unwrap();
        let db = client.database(&name);
        // List the names of the databases in that deployment.
        let db_names = client.list_database_names(None, None).await.unwrap();
        info!("databases: {:?}", db_names);

        Self { client, db, url }
    }

    async fn create(
        &self,
        class: &str,
        mut doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection> {
        let t = Utc::now();
        Self::update_doc(&mut doc, t);
        trace!("create new {:?}: {:?}", class, doc);
        let r = self
            .db
            .collection(&class)
            .insert_one(doc.clone(), None)
            .await;
        if let Ok(r) = r {
            doc.insert(Self::ID, r.inserted_id);
            Ok(Self::expose(doc))
        } else {
            internal_server_error("Cannot create object")
        }
    }

    async fn retrieve(
        &self,
        class: &str,
        filter: Document,
        user: UserKind,
    ) -> Result<Vec<Document>, Rejection> {
        let filter = doc!["$and": vec![filter, Self::read_filter(&user)]];
        trace!("retrieve {:?} with filter {:?}", class, filter);
        let mut cursor = self.db.collection(class).find(filter, None).await.unwrap();
        let mut docs = Vec::new();
        while let Some(result) = cursor.next().await {
            match result {
                Ok(doc) => {
                    docs.push(Self::expose(doc));
                }
                Err(e) => return internal_server_error("retrieve error"),
            }
        }
        Ok(docs)
    }

    // See: https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndUpdate/
    async fn update(
        &self,
        class: &str,
        id: &str,
        doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection> {
        let oid = mongodb::bson::oid::ObjectId::with_string(id).unwrap();
        let mut filter = Self::write_filter(&user);
        filter.insert(Self::ID, oid);

        trace!(
            "update {:?} by id {:?} with with {:?} filtered by {:?}",
            class,
            id,
            doc,
            filter,
        );
        let result = self
            .db
            .collection(class)
            .find_one_and_update(filter, doc! { "$set": &doc }, None)
            .await;

        match result {
            Ok(r) => {
                if let Some(doc) = r {
                    Ok(doc)
                } else {
                    error::not_found("Object not found")
                }
            }
            Err(e) => error::internal_server_error("Unexpected query error"),
        }
    }

    async fn delete(&self, class: &str, id: &str, user: UserKind) -> Result<Document, Rejection> {
        trace!("delete {:?} by id {:?}", class, id);
        let oid = mongodb::bson::oid::ObjectId::with_string(id).unwrap();
        let mut filter = Self::write_filter(&user);
        filter.insert(Self::ID, oid);

        let result = self
            .db
            .collection(class)
            .find_one_and_delete(filter, None)
            .await
            .unwrap();
        result.map_or_else(|| error::not_found(""), |doc| Ok(doc))
    }
}
