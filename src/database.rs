use crate::{
    error::{self, bad_request, internal_server_error, not_found},
    user::UserKind,
};
use chrono::Utc;
use chrono::{DateTime, SecondsFormat};
use mongodb::bson::{doc, Document};
use std::result::Result;
use tokio::stream::StreamExt;
use warp::Rejection;

use async_trait::async_trait;

/// `OBJECT_ID` field is immutable for non-master users.
pub const OBJECT_ID: &'static str = "objectId";
/// `ACL` field is immutable for non-master users.
pub const ACL: &'static str = "acl";

pub const CREATED_AT: &'static str = "createdAt";
pub const UPDATED_AT: &'static str = "updatedAt";

#[async_trait]
pub trait Database {
    async fn from_url(url: String) -> Self;

    async fn create(
        &self,
        class: &str,
        mut doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection>;

    async fn retrieve(
        &self,
        class: &str,
        filter: Document,
        user: UserKind,
    ) -> Result<Vec<Document>, Rejection>;

    async fn update(
        &self,
        class: &str,
        id: &str,
        mut doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection>;

    async fn delete(&self, class: &str, id: &str, user: UserKind) -> Result<Document, Rejection>;
}

#[derive(Debug, Clone)]
pub struct Mongodb {
    url: String,
    client: mongodb::Client,
    db: mongodb::Database,
}

impl Mongodb {
    // ID is generated by MongoDB, including objectID and createdAt
    const ID: &'static str = "_id";

    fn update_doc(doc: &mut Document, t: DateTime<Utc>) {
        doc.insert(UPDATED_AT, t);
    }

    fn expose(mut doc: Document) -> Document {
        if let Ok(id) = doc.get_object_id(Self::ID) {
            let id = id.clone();
            doc.insert(
                CREATED_AT,
                id.timestamp().to_rfc3339_opts(SecondsFormat::Secs, true),
            );
            doc.insert(OBJECT_ID, id.to_string());
            doc.remove(Self::ID);
        }
        if let Ok(x) = doc.get_datetime(UPDATED_AT) {
            let t = x.to_rfc3339_opts(SecondsFormat::Secs, true);
            doc.insert(UPDATED_AT, t);
        }
        doc
    }

    // FIXME: dfs
    /// Convert `objectId` field to `_id`
    fn inner_filter(mut filter: Document) -> Result<Document, Rejection> {
        if let Some(v) = filter.remove(OBJECT_ID) {
            match v.as_str() {
                None => return bad_request("Unexpected non-string objectId field"),
                Some(id) => {
                    match mongodb::bson::oid::ObjectId::with_string(id) {
                        Ok(oid) => {
                            filter.insert(Self::ID, oid);
                        }
                        Err(e) => {
                            return not_found("Object not found");
                        }
                    };
                }
            };
        }
        Ok(filter)
    }

    /// Read filter for certain user in MongoDB
    ///
    /// If user_id is found for this object such as `_acl.user_id` is one of `i, r, w`,
    /// representing that object is invisible, read-only, read-write to user_id respectively.
    ///
    /// Else if ACL not found for such user, try using the acl of `*` user
    ///
    /// Otherwise, default to read-write
    fn read_filter(user: &UserKind) -> Document {
        match user {
            UserKind::Master => {
                doc! {}
            }
            UserKind::Client(user) => {
                let acl_user = format!("{}.{}", ACL, user.id);
                doc! {"$or": vec![
                    doc! {&acl_user: "r"},
                    doc! {&acl_user: "w"},
                    doc! {"$and": vec![
                        doc!{acl_user: doc! {"$exists": false}},
                        doc! {format!("{}.*", ACL): {"$ne": "i"} },
                    ]}
                ]}
            }
            UserKind::Guest => {
                doc! {format!("{}.*", ACL): {"$ne": "i"} }
            }
        }
    }

    /// Write filter for certain user in MongoDB
    ///
    /// If user_id is found for this object such as `acl.user_id` is one of `i, r, w`,
    /// it means that the object is invisible, read-only, read-write to user_id respectively.
    ///
    /// Else if ACL not found for such user, try using the acl of `*` user
    ///
    /// Otherwise, default to read-write
    fn write_filter(user: &UserKind) -> Document {
        match user {
            UserKind::Master => {
                doc! {}
            }
            UserKind::Client(user) => {
                let acl_user = format!("{}.{}", ACL, user.id);
                let acl_all = format!("{}.*", ACL);
                let not_exists = doc! {"$exists": false};
                doc! {"$or": vec![
                    doc! {&acl_user: "w"},
                    doc! {"$and": vec![
                        doc!{&acl_user: not_exists},
                        doc!{"$and": vec![
                            doc!{&acl_all: {"$ne": "i"}},
                            doc!{acl_all: {"$ne": "r"}},
                        ]},
                    ]}
                ]}
            }
            UserKind::Guest => {
                let acl_all = format!("{}.*", ACL);
                doc! {"$and": vec![
                    doc!{&acl_all: {"$ne": "i"}},
                    doc!{acl_all: {"$ne": "r"}},
                ]}
            }
        }
    }
}

#[async_trait]
impl Database for Mongodb {
    async fn from_url(url: String) -> Self {
        let client_options = mongodb::options::ClientOptions::parse(&url).await.unwrap();
        let name = client_options
            .clone()
            .credential
            .unwrap()
            .source
            .expect("mongodb database name should be provided in url.");
        let client = mongodb::Client::with_options(client_options).unwrap();
        let db = client.database(&name);
        // List the names of the databases in that deployment.
        let db_names = client.list_database_names(None, None).await.unwrap();
        info!("databases: {:?}", db_names);

        Self { client, db, url }
    }

    async fn create(
        &self,
        class: &str,
        mut doc: Document,
        _user: UserKind,
    ) -> Result<Document, Rejection> {
        let t = Utc::now();
        Self::update_doc(&mut doc, t);
        trace!("create new {:?}: {:?}", class, doc);
        let result = self
            .db
            .collection(&class)
            .insert_one(doc.clone(), None)
            .await;
        match result {
            Ok(r) => {
                doc.insert(Self::ID, r.inserted_id);
                Ok(Self::expose(doc))
            }
            _ => internal_server_error("Cannot create object"),
        }
    }

    async fn retrieve(
        &self,
        class: &str,
        filter: Document,
        user: UserKind,
    ) -> Result<Vec<Document>, Rejection> {
        let filter = Self::inner_filter(filter)?;

        let filter = doc!["$and": vec![filter, Self::read_filter(&user)]];
        trace!("retrieve {:?} with filter {:?}", class, filter);
        let mut cursor = self.db.collection(class).find(filter, None).await.unwrap();
        let mut docs = Vec::new();
        while let Some(result) = cursor.next().await {
            match result {
                Ok(doc) => {
                    docs.push(Self::expose(doc));
                }
                Err(_) => return internal_server_error("retrieve error"),
            }
        }
        trace!("retrieve result: {:?}", docs);
        Ok(docs)
    }

    /// Update a document in specific class with id by user and return the document before updating.
    ///
    /// Master user can update with document of any content,
    /// while others updating `objectId` and `acl` field will be rejected.
    async fn update(
        &self,
        class: &str,
        id: &str,
        mut doc: Document,
        user: UserKind,
    ) -> Result<Document, Rejection> {
        let req_doc = doc.clone();
        doc.remove(OBJECT_ID); // Remove it since `objectId` is mapped onto `_id`.
        match user {
            UserKind::Master => {
                // Master can update with any document
            }
            _ => {
                // Client and Guest cannot update ACL and objectId
                if let Some(x) = doc.remove(ACL) {
                    return bad_request("Cannot update ACL");
                }
            }
        }

        if doc.is_empty() {
            return bad_request("Cannot update with empty data");
        }

        Self::update_doc(&mut doc, Utc::now());

        let oid = mongodb::bson::oid::ObjectId::with_string(id)
            .map_or_else(|e| not_found("Object ID invalid"), |d| Ok(d))?;

        let filter = doc! {Self::ID: oid};
        let filter = doc!["$and": vec![filter, Self::write_filter(&user)]];
        trace!(
            "update {:?} by id {:?} with with {:?} filtered by {:?}",
            class,
            id,
            doc,
            filter,
        );

        let result = self
            .db
            .collection(class)
            .find_one_and_update(filter, doc! { "$set": &doc }, None)
            .await;

        match result {
            Ok(Some(doc)) => {
                let doc = Self::expose(doc);
                trace!("update result: {}", doc);
                Ok(doc)
            }
            Ok(None) => error::not_found("Object not found"),
            Err(e) => {
                error!("update error {}", e);
                error::internal_server_error("Unexpected query error")
            }
        }
    }

    async fn delete(&self, class: &str, id: &str, user: UserKind) -> Result<Document, Rejection> {
        trace!("delete {:?} by id {:?}", class, id);
        let oid = mongodb::bson::oid::ObjectId::with_string(id)
            .map_or_else(|e| not_found("Object ID invalid"), |s| Ok(s))?;

        let mut filter = Self::write_filter(&user);
        filter.insert(Self::ID, oid);

        let result = self
            .db
            .collection(class)
            .find_one_and_delete(filter, None)
            .await;
        match result {
            Ok(Some(doc)) => Ok(Self::expose(doc)),
            Ok(None) => error::not_found("Object not found"),
            Err(_) => error::internal_server_error("Unexpected query error"),
        }
    }
}
