<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `bson` crate."><meta name="keywords" content="rust, rustlang, rust-lang, bson"><title>bson - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../bson/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate bson</p><div class='block version'><p>Version 1.1.0</p></div><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all bson's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'bson', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/bson/lib.rs.html#22-217' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>bson</a></span></h1><div class='docblock'><p>BSON, short for Binary JSON, is a binary-encoded serialization of JSON-like documents.
Like JSON, BSON supports the embedding of documents and arrays within other documents
and arrays. BSON also contains extensions that allow representation of data types that
are not part of the JSON spec. For example, BSON has a datetime type and a binary data type.</p>
<pre><code class="language-text">// JSON equivalent
{&quot;hello&quot;: &quot;world&quot;}

// BSON encoding
\x16\x00\x00\x00                   // total document size
\x02                               // 0x02 = type String
hello\x00                          // field name
\x06\x00\x00\x00world\x00          // field value
\x00                               // 0x00 = type EOO ('end of object')
</code></pre>
<p>BSON is the primary data representation for <a href="https://www.mongodb.com/">MongoDB</a>, and this crate is used in the
<a href="https://docs.rs/mongodb/0.10.0/mongodb/"><code>mongodb</code></a> driver crate in its API and implementation.</p>
<p>For more information about BSON itself, see <a href="http://bsonspec.org">bsonspec.org</a>.</p>
<h2 id="bson-values" class="section-header"><a href="#bson-values">BSON values</a></h2>
<p>Many different types can be represented as a BSON value, including 32-bit and 64-bit signed
integers, 64 bit floating point numbers, strings, datetimes, embedded documents, and more. To
see a full list of possible BSON values, see the <a href="http://bsonspec.org/spec.html">BSON specification</a>. The various
possible BSON values are modeled in this crate by the <a href="enum.Bson.html"><code>Bson</code></a> enum.</p>
<h3 id="creating-bson-instances" class="section-header"><a href="#creating-bson-instances">Creating <code>Bson</code> instances</a></h3>
<p><a href="enum.Bson.html"><code>Bson</code></a> values can be instantiated directly or via the
<a href="macro.bson.html"><code>bson!</code></a> macro:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="ident">Bson</span>::<span class="ident">String</span>(<span class="string">&quot;hello world&quot;</span>.<span class="ident">to_string</span>());
<span class="kw">let</span> <span class="ident">int</span> <span class="op">=</span> <span class="ident">Bson</span>::<span class="ident">Int32</span>(<span class="number">5</span>);
<span class="kw">let</span> <span class="ident">array</span> <span class="op">=</span> <span class="ident">Bson</span>::<span class="ident">Array</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="ident">Bson</span>::<span class="ident">Int32</span>(<span class="number">5</span>), <span class="ident">Bson</span>::<span class="ident">Boolean</span>(<span class="bool-val">false</span>)]);

<span class="kw">let</span> <span class="ident">string</span>: <span class="ident">Bson</span> <span class="op">=</span> <span class="string">&quot;hello world&quot;</span>.<span class="ident">into</span>();
<span class="kw">let</span> <span class="ident">int</span>: <span class="ident">Bson</span> <span class="op">=</span> <span class="number">5i32</span>.<span class="ident">into</span>();

<span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="macro">bson</span><span class="macro">!</span>(<span class="string">&quot;hello world&quot;</span>);
<span class="kw">let</span> <span class="ident">int</span> <span class="op">=</span> <span class="macro">bson</span><span class="macro">!</span>(<span class="number">5</span>);
<span class="kw">let</span> <span class="ident">array</span> <span class="op">=</span> <span class="macro">bson</span><span class="macro">!</span>([<span class="number">5</span>, <span class="bool-val">false</span>]);</pre></div>
<p><a href="macro.bson.html"><code>bson!</code></a> has supports both array and object literals, and it automatically
converts any values specified to <a href="enum.Bson.html"><code>Bson</code></a>, provided they are <code>Into&lt;Bson&gt;</code>.</p>
<h3 id="bson-value-unwrapping" class="section-header"><a href="#bson-value-unwrapping"><code>Bson</code> value unwrapping</a></h3>
<p><a href="enum.Bson.html"><code>Bson</code></a> has a number of helper methods for accessing the underlying native Rust
types. These helpers can be useful in circumstances in which the specific type of a BSON value
is known ahead of time.</p>
<p>e.g.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">Bson</span>::<span class="ident">Int32</span>(<span class="number">5</span>);
<span class="kw">let</span> <span class="ident">int</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">as_i32</span>(); <span class="comment">// Some(5)</span>
<span class="kw">let</span> <span class="ident">bool</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">as_bool</span>(); <span class="comment">// None</span>

<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="macro">bson</span><span class="macro">!</span>([<span class="bool-val">true</span>]);
<span class="kw">let</span> <span class="ident">array</span> <span class="op">=</span> <span class="ident">value</span>.<span class="ident">as_array</span>(); <span class="comment">// Some(&amp;Vec&lt;Bson&gt;)</span></pre></div>
<h2 id="bson-documents" class="section-header"><a href="#bson-documents">BSON documents</a></h2>
<p>BSON documents are ordered maps of UTF-8 encoded strings to BSON values. They are logically
similar to JSON objects in that they can contain subdocuments, arrays, and values of several
different types. This crate models BSON documents via the
<a href="document/struct.Document.html"><code>Document</code></a> struct.</p>
<h3 id="creating-documents" class="section-header"><a href="#creating-documents">Creating <code>Document</code>s</a></h3>
<p><a href="document/struct.Document.html"><code>Document</code></a>s can be created directly either from a byte
reader containing BSON data or via the <code>doc!</code> macro:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="ident">hex</span>::<span class="ident">decode</span>(<span class="string">&quot;0C0000001069000100000000&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">doc</span> <span class="op">=</span> <span class="ident">Document</span>::<span class="ident">from_reader</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">bytes</span>.<span class="ident">as_slice</span>()).<span class="ident">unwrap</span>(); <span class="comment">// { &quot;i&quot;: 1 }</span>

<span class="kw">let</span> <span class="ident">doc</span> <span class="op">=</span> <span class="macro">doc</span><span class="macro">!</span> {
   <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>,
   <span class="string">&quot;int&quot;</span>: <span class="number">5</span>,
   <span class="string">&quot;subdoc&quot;</span>: { <span class="string">&quot;cat&quot;</span>: <span class="bool-val">true</span> },
};</pre></div>
<p><a href="macro.doc.html"><code>doc!</code></a> works similarly to <a href="macro.bson.html"><code>bson!</code></a>, except that it always
returns a <a href="document/struct.Document.html"><code>Document</code></a> rather than a <a href="enum.Bson.html"><code>Bson</code></a>.</p>
<h3 id="document-member-access" class="section-header"><a href="#document-member-access"><code>Document</code> member access</a></h3>
<p><a href="document/struct.Document.html"><code>Document</code></a> has a number of methods on it to facilitate member
access:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">doc</span> <span class="op">=</span> <span class="macro">doc</span><span class="macro">!</span> {
   <span class="string">&quot;string&quot;</span>: <span class="string">&quot;string&quot;</span>,
   <span class="string">&quot;bool&quot;</span>: <span class="bool-val">true</span>,
   <span class="string">&quot;i32&quot;</span>: <span class="number">5</span>,
   <span class="string">&quot;doc&quot;</span>: { <span class="string">&quot;x&quot;</span>: <span class="bool-val">true</span> },
};

<span class="comment">// attempt get values as untyped Bson</span>
<span class="kw">let</span> <span class="ident">none</span> <span class="op">=</span> <span class="ident">doc</span>.<span class="ident">get</span>(<span class="string">&quot;asdfadsf&quot;</span>); <span class="comment">// None</span>
<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">doc</span>.<span class="ident">get</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Some(&amp;Bson::String(&quot;string&quot;))</span>

<span class="comment">// attempt to get values with explicit typing</span>
<span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="ident">doc</span>.<span class="ident">get_str</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Ok(&quot;string&quot;)</span>
<span class="kw">let</span> <span class="ident">subdoc</span> <span class="op">=</span> <span class="ident">doc</span>.<span class="ident">get_document</span>(<span class="string">&quot;doc&quot;</span>); <span class="comment">// Some(Document({ &quot;x&quot;: true }))</span>
<span class="kw">let</span> <span class="ident">error</span> <span class="op">=</span> <span class="ident">doc</span>.<span class="ident">get_i64</span>(<span class="string">&quot;i32&quot;</span>); <span class="comment">// Err(...)</span></pre></div>
<h2 id="modeling-bson-with-strongly-typed-data-structures" class="section-header"><a href="#modeling-bson-with-strongly-typed-data-structures">Modeling BSON with strongly typed data structures</a></h2>
<p>While it is possible to work with documents and BSON values directly, it will often introduce a
lot of boilerplate for verifying the necessary keys are present and their values are the correct
types. <a href="https://serde.rs/"><code>serde</code></a> provides a powerful way of mapping BSON data into Rust data structures largely
automatically, removing the need for all that boilerplate.</p>
<p>e.g.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Person</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">age</span>: <span class="ident">i32</span>,
    <span class="ident">phones</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
}

<span class="comment">// Some BSON input data as a `Bson`.</span>
<span class="kw">let</span> <span class="ident">bson_data</span>: <span class="ident">Bson</span> <span class="op">=</span> <span class="macro">bson</span><span class="macro">!</span>({
    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,
    <span class="string">&quot;age&quot;</span>: <span class="number">43</span>,
    <span class="string">&quot;phones&quot;</span>: [
        <span class="string">&quot;+44 1234567&quot;</span>,
        <span class="string">&quot;+44 2345678&quot;</span>
    ]
});

<span class="comment">// Deserialize the Person struct from the BSON data, automatically</span>
<span class="comment">// verifying that the necessary keys are present and that they are of</span>
<span class="comment">// the correct types.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">person</span>: <span class="ident">Person</span> <span class="op">=</span> <span class="ident">bson</span>::<span class="ident">from_bson</span>(<span class="ident">bson_data</span>).<span class="ident">unwrap</span>();

<span class="comment">// Do things just like with any other Rust data structure.</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Redacting {}&#39;s record.&quot;</span>, <span class="ident">person</span>.<span class="ident">name</span>);
<span class="ident">person</span>.<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;REDACTED&quot;</span>.<span class="ident">to_string</span>();

<span class="comment">// Get a serialized version of the input data as a `Bson`.</span>
<span class="kw">let</span> <span class="ident">redacted_bson</span> <span class="op">=</span> <span class="ident">bson</span>::<span class="ident">to_bson</span>(<span class="kw-2">&amp;</span><span class="ident">person</span>).<span class="ident">unwrap</span>();</pre></div>
<p>Any types that implement <code>Serialize</code> and <code>Deserialize</code> can be used in this way. Doing so helps
separate the &quot;business logic&quot; that operates over the data from the (de)serialization logic that
translates the data to/from its serialized form. This can lead to more clear and concise code
that is also less error prone.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use self::bson::<a class="struct" href="../bson/document/struct.Document.html" title="struct bson::document::Document">Document</a>;</code></td></tr><tr><td><code>pub use self::de::<a class="fn" href="../bson/de/fn.from_bson.html" title="fn bson::de::from_bson">from_bson</a>;</code></td></tr><tr><td><code>pub use self::de::<a class="fn" href="../bson/de/fn.from_document.html" title="fn bson::de::from_document">from_document</a>;</code></td></tr><tr><td><code>pub use self::decimal128::<a class="struct" href="../bson/decimal128/struct.Decimal128.html" title="struct bson::decimal128::Decimal128">Decimal128</a>;</code></td></tr><tr><td><code>pub use self::ser::<a class="fn" href="../bson/ser/fn.to_bson.html" title="fn bson::ser::to_bson">to_bson</a>;</code></td></tr><tr><td><code>pub use self::ser::<a class="fn" href="../bson/ser/fn.to_document.html" title="fn bson::ser::to_document">to_document</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="compat/index.html" title='bson::compat mod'>compat</a></td><td class='docblock-short'><p>Backward compatibility</p>
</td></tr><tr class='module-item'><td><a class="mod" href="de/index.html" title='bson::de mod'>de</a></td><td class='docblock-short'><p>Deserializer</p>
</td></tr><tr class='module-item'><td><a class="mod" href="decimal128/index.html" title='bson::decimal128 mod'>decimal128</a></td><td class='docblock-short'><p><a href="https://github.com/mongodb/specifications/blob/master/source/bson-decimal128/decimal128.rst">BSON Decimal128</a> data type representation</p>
</td></tr><tr class='module-item'><td><a class="mod" href="document/index.html" title='bson::document mod'>document</a></td><td class='docblock-short'><p>A BSON document represented as an associative HashMap with insertion ordering.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="extjson/index.html" title='bson::extjson mod'>extjson</a></td><td class='docblock-short'><p>Deserialization and serialization of <a href="https://docs.mongodb.com/manual/reference/mongodb-extended-json/">MongoDB Extended JSON v2</a></p>
</td></tr><tr class='module-item'><td><a class="mod" href="oid/index.html" title='bson::oid mod'>oid</a></td><td class='docblock-short'><p>ObjectId</p>
</td></tr><tr class='module-item'><td><a class="mod" href="ser/index.html" title='bson::ser mod'>ser</a></td><td class='docblock-short'><p>Serializer</p>
</td></tr><tr class='module-item'><td><a class="mod" href="spec/index.html" title='bson::spec mod'>spec</a></td><td class='docblock-short'><p>Constants derived from the <a href="http://bsonspec.org/spec.html">BSON Specification Version 1.1</a>.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.bson.html" title='bson::bson macro'>bson</a></td><td class='docblock-short'><p>Construct a bson::BSON value from a literal.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.doc.html" title='bson::doc macro'>doc</a></td><td class='docblock-short'><p>Construct a bson::Document value.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Binary.html" title='bson::Binary struct'>Binary</a></td><td class='docblock-short'><p>Represents a BSON binary value.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DateTime.html" title='bson::DateTime struct'>DateTime</a></td><td class='docblock-short'><p><code>DateTime</code> representation in struct for serde serialization</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DbPointer.html" title='bson::DbPointer struct'>DbPointer</a></td><td class='docblock-short'><p>Represents a DBPointer. (Deprecated)</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Deserializer.html" title='bson::Deserializer struct'>Deserializer</a></td><td class='docblock-short'><p>Serde Deserializer</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.JavaScriptCodeWithScope.html" title='bson::JavaScriptCodeWithScope struct'>JavaScriptCodeWithScope</a></td><td class='docblock-short'><p>Represents a BSON code with scope value.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Regex.html" title='bson::Regex struct'>Regex</a></td><td class='docblock-short'><p>Represents a BSON regular expression value.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Serializer.html" title='bson::Serializer struct'>Serializer</a></td><td class='docblock-short'><p>Serde Serializer</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Timestamp.html" title='bson::Timestamp struct'>Timestamp</a></td><td class='docblock-short'><p>Represents a BSON timestamp value.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Bson.html" title='bson::Bson enum'>Bson</a></td><td class='docblock-short'><p>Possible BSON value types.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.Array.html" title='bson::Array type'>Array</a></td><td class='docblock-short'><p>Alias for <code>Vec&lt;Bson&gt;</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "bson";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>